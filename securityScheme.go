package oasm

import (
	"encoding/json"
	"strconv"
)

// Defines a security scheme that can be used by the operations. Supported schemes are HTTP authentication, an API key
// (either as a header or as a query parameter), OAuth2's common flows (implicit, password, application and access code)
// as defined in RFC6749, and OpenID Connect Discovery.
type SecuritySchemeDoc struct {

	// REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "oauth2", "openIdConnect".
	Type SecurityType

	// A short description for security scheme. CommonMark syntax MAY be used for rich text representation.
	Description string

	// 	REQUIRED for apiKey. The name of the header, query or cookie parameter to be used.
	Name string

	// REQUIRED for apiKey. The location of the API key. Valid values are "query", "header" or "cookie".
	In SecurityInRequest

	// REQUIRED for http.
	// The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.
	Scheme HTTPAuthScheme

	// For http (bearer). A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually
	// generated by an authorization server, so this information is primarily for documentation purposes.
	BearerFormat string

	// REQUIRED for oauth2. An object containing configuration information for the flow types supported.
	Flows OAuthFlows

	// REQUIRED for openIdConnect.
	// OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL.
	OpenIdConnectUrl string
}

func (s *SecuritySchemeDoc) MarshalJSON() (_ []byte, err error) {
	x := make(JSON)
	x["type"] = json.RawMessage(strconv.Quote(string(s.Type)))
	if s.Description != "" {
		x["description"] = json.RawMessage(strconv.Quote(s.Description))
	}
	if s.Type == SecurityApiKey {
		x["name"] = json.RawMessage(strconv.Quote(s.Name))
		x["in"] = json.RawMessage(strconv.Quote(string(s.In)))
	} else if s.Type == SecurityHttp {
		x["scheme"] = json.RawMessage(strconv.Quote(string(s.Scheme)))
		if s.Scheme == AuthBearer && s.BearerFormat != "" {
			x["bearerFormat"] = json.RawMessage(strconv.Quote(s.BearerFormat))
		}
	} else if s.Type == SecurityOauth2 {
		if s.Flows == nil {
			s.Flows = make(OAuthFlows)
		}
		x["flows"], err = json.Marshal(s.Flows)
		if err != nil {
			return
		}
	} else if s.Type == SecurityOpenIdConnect {
		x["openIdConnectUrl"] = json.RawMessage(strconv.Quote(s.OpenIdConnectUrl))
	}
	return json.Marshal(x)
}
